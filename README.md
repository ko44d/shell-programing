# shell-programing
## シェルプログラムを書くための基本事項
- シェルプログラムの先頭には#!/bin/shを書く
- シェルプログラムには実行権限(xフラグ)を与える

## 1行の取り扱い
- コマンドをコマンドとして区切る働きをするのが「改行コード」である

## ワイルドカード
- \* 文字列全部
- ? 1文字
- [...] [ ]の中に含まれる文字のどれか1つ
- [!...] [ ]に含まれない文字

## 特殊文字
### クォート
- シェルが特殊だと判断する文字の意味を剥奪すること
- エスケープすること
- 利用目的
    - 何かコマンドを実行させるとき
    - 渡す引数をシェルが自動的に解釈しないようにしたいとき

### バックスラッシュ
- 直後の文字の特殊な意味をなくす機能

### シングルクォーテーション
- シングルクォーテーションで囲まれた文字列('...')の中の特殊文字は全て普通の文字と同じ扱いになる

### ダブルクォーテーション
- $ ` \という3つの特殊文字はダブルクォートで囲まれてもエスケープできない
- 上記の3つ以外の特殊文字の意味をエスケープする

### バッククォート
- バッククォートで囲まれた中に書かれたコマンドを実行してその結果をその位置に書き込む

### コマンド終了時のステータス
- コマンドが正しく終了したときに0、そうでない場合に1を終了時にセットする
- 0 成功 true
- 0以外 失敗 false
- コマンドの実行結果は$?という変数にセットされる
```
# echo コマンドで確認できる
echo $?
```

## コマンドセパレータ

### セミコロン
- ;
- 1つのコマンドの区切り
- 改行と同じ
- 複数行にまたがる記述を1行にまとめられること

### パイプ
- |
- 左から右へ流していくパイプライン処理
- 出力された結果を次のコマンドの入力にする

### アンバサダー
- &
- バックグラウンドで実行させる

### OR演算子
- ||
- 左側のコマンドが失敗したとき初めて右側のコマンドを実行するように動作する

### AND演算子
- &&
- 左側のコマンドが成功したときだけ右側のコマンドを実行するように動作する

## コマンドのグルーピング

### 丸括弧
- 現行の状態を変えたくないが、変えた状態で何かをやらなくてはいけないというような場合に利用する
- 括弧で囲まれたコマンド群は現在の動作しているシェルとは別に、サブシェルの元で動作することになる
    - サブシェルとは、今のシェルが新しくシェルを動作させ、その中で動作するもの
- 今のシェルは、そのサブシェルが終了するまで次の処理には移行できない
- 今のシェルとサブシェルは親子関係である。親の環境は子に引き継ぐことはできる。逆に子の環境は親に引き継ぐことはできない。
- 子シェルの中でディレクトリ移動等、環境を変えたりして何らかの処理を行なった場合、親に戻ってきた時に環境は何も変わらないまま元のままの状態をキープする

### 中括弧
- 複数のコマンドの結果をひとまとめにしたい時に使う
- 現行のシェルの中で実行される
- 中括弧の前後にはスペースが必要である
- 中括弧の中の最後のコマンドはセミコロンを打っておかなくてはいけない
```
# 以下のように書くことでスペース、セミコロンを意識せずにかける

{
    command1
    command2
}

```

## シェル変数
- シェル変数には、アルファベット、数字、アンダースコア（_）を使うことができる
- 変数の最初の文字に数字は使えない
- 変数にセットされる値は全て文字列として扱われる
```
variable=value
```
- =の前後にスペースを入れてはいけない
- =で結ぶことで変数にセットされる
- シェル変数の値を利用する場合、$を先頭につける
- 以下のシェル変数の定義ではundefined variablesとなる。値には何もないという意味。シェル変数にヌルをセットする。
```
variable=
variable=""
```
### =によるシェルの設定
```
${variable:=value}
${variable=value}
```
- :がある場合、シェル変数が未使用、ヌルである時にvalueが使われる
- :がない場合、ヌルである時もvalueになる

### -によるシェルの設定
```
${variable:-value}
${variable-value}
```
- 変数がこれまで未使用、未設定の状態の時に値を代入しないまま、指定した値をそのまま返す
- 位置パラメタを使うことができる

### ?によるシェル変数の設定
```
${variable:?message}
${variable?message}
```
- 変数がこれまで未使用、未設定であるかどうかを確認する時に使う
- 変数がこれまで未使用、未設定である時にmessageの部分が表示される
- シェルスクリプトの場合はここで処理が終了する

### +によるシェル変数の設定
```
${variable:+message}
${variable+message}
```
- 変数に何かしらの値が設定されている場合に、値を切り替えて表示する
- 元の変数の値は変更しない
- 変数の値を変更せずにそのときだけ結果を変えたい場合に利用する
```
$ echo ${ABC:+zzz}

$ ABC=www
$ echo $ABC
www
$ echo ${ABC:+zzz}
zzz
$ echo $ABC
www
```
### 位置パラメタ
- コマンドはその行を処理するに当たって、特殊文字を展開したりクォーテーションを処理したのちあるパラメタにそれぞれの引数を入れている。これを位置パラメタと呼ぶ。
- 位置パラメタにセットされるのは頭から10個までである
- $0-9は書き込み禁止の変数である
#### $#
- あるコマンドに渡される引数の数
- $0以外のコマンドに渡された引数の数
#### $*
- 引数全体を表現する
- ダブルクォートで括ると引数全体を1個のダブルクォートで囲んだ状態で展開する
#### $@
- 引数全体を表現する
- ダブルクォートで括ると引数をそれぞれ1個のダブルクォートで囲んだ状態で展開する
### $?
- コマンド実行時の終了ステータスを表す変数
- &を用いてバックグラウンドで実行したコマンドに対しては無効である
### $$
- 現在動作しているコマンドの「プロセスID」がセットされる
- プロセスIDとは
    - UNIX上で管理さっるものであり、何かコマンドが実行された時に、必ずそのUNIX上の一意に決定されて割り当てられる
- ユニークな番号を何かにつけたい時に利用する
### $!
- &を用いてバックグラウンドで実行させた時にそのコマンドのプロセスIDがセットされる
### $-
- シェルの起動時のフラグやsetコマンドを使って設定したフラグの一覧がセットされる

## ファイルディスクリプタ

| ファイルディスクリプタ | 詳細 |
| --- | --- |
| 0 | 標準入力 |
| 1 | 標準出力 |
| 2 | 標準エラー |

## リダイレクション

|  記述  | 記述（ファイルディスクリプタ省略なし） | 詳細                  |
|   --   | --      | --                                                   |
| >file  | 1>file  | 標準出力をfileというファイルに書く                   |
| >>file | 1>>file | 標準出力をfileというファイルに追加書きする           |
| >&m    | 1>>&m   | 標準出力をm番のファイルディスクリプタに書く          |
| >&-    | 1>&-    | 標準出力をクローズする                               |
| <file  | 0<file  | 標準入力をfieというファイルから読み込む              |
| <&m    | 0<&m    | 標準入力を mというファイルディスクリプタから読み込む |
| <&-    | 0<&-    | 標準入力をクローズする                               |
| <<word | 0<<word | 標準入力をヒア・ドキュメントから読み込む             |

ファイルディスクリプタの番号を変更すれば、任意のファイルディスクリプタへの操作ができる。

### 注意
- 指定できるファイルディスクリプタは0-9番まで
- リダイレクト記号とファイルディスクリプタ番号との間にスペースを空けない
